{"version":3,"sources":["../../../../../../Desktop/dharwin_boilerplate/node_modules/react-redux/es/index.js","../../../../../../Desktop/dharwin_boilerplate/node_modules/react-redux/es/utils/reactBatchedUpdates.js","../../../../../../Desktop/dharwin_boilerplate/node_modules/react-redux/es/utils/batch.js","../../../../../../Desktop/dharwin_boilerplate/node_modules/react-redux/es/hooks/useSelector.js","../../../../../../Desktop/dharwin_boilerplate/node_modules/react-redux/es/components/Context.js","../../../../../../Desktop/dharwin_boilerplate/node_modules/react-redux/es/hooks/useReduxContext.js","../../../../../../Desktop/dharwin_boilerplate/node_modules/react-redux/es/utils/useSyncExternalStore.js","../../../../../../Desktop/dharwin_boilerplate/node_modules/react-redux/es/components/connect.js","../../../../../../Desktop/dharwin_boilerplate/node_modules/react-redux/es/utils/warning.js","../../../../../../Desktop/dharwin_boilerplate/node_modules/react-redux/es/connect/verifySubselectors.js","../../../../../../Desktop/dharwin_boilerplate/node_modules/react-redux/es/connect/selectorFactory.js","../../../../../../Desktop/dharwin_boilerplate/node_modules/react-redux/es/utils/bindActionCreators.js","../../../../../../Desktop/dharwin_boilerplate/node_modules/react-redux/es/utils/isPlainObject.js","../../../../../../Desktop/dharwin_boilerplate/node_modules/react-redux/es/utils/verifyPlainObject.js","../../../../../../Desktop/dharwin_boilerplate/node_modules/react-redux/es/connect/wrapMapToProps.js","../../../../../../Desktop/dharwin_boilerplate/node_modules/react-redux/es/connect/invalidArgFactory.js","../../../../../../Desktop/dharwin_boilerplate/node_modules/react-redux/es/connect/mapDispatchToProps.js","../../../../../../Desktop/dharwin_boilerplate/node_modules/react-redux/es/connect/mapStateToProps.js","../../../../../../Desktop/dharwin_boilerplate/node_modules/react-redux/es/connect/mergeProps.js","../../../../../../Desktop/dharwin_boilerplate/node_modules/react-redux/es/utils/Subscription.js","../../../../../../Desktop/dharwin_boilerplate/node_modules/react-redux/es/utils/useIsomorphicLayoutEffect.js","../../../../../../Desktop/dharwin_boilerplate/node_modules/react-redux/es/utils/shallowEqual.js","../../../../../../Desktop/dharwin_boilerplate/node_modules/react-redux/es/components/Provider.js","../../../../../../Desktop/dharwin_boilerplate/node_modules/react-redux/es/hooks/useStore.js","../../../../../../Desktop/dharwin_boilerplate/node_modules/react-redux/es/hooks/useDispatch.js"],"sourcesContent":["// The primary entry point assumes we're working with standard ReactDOM/RN, but\n// older versions that do not include `useSyncExternalStore` (React 16.9 - 17.x).\n// Because of that, the useSyncExternalStore compat shim is needed.\nimport { useSyncExternalStore } from 'use-sync-external-store/shim';\nimport { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector';\nimport { unstable_batchedUpdates as batch } from './utils/reactBatchedUpdates';\nimport { setBatch } from './utils/batch';\nimport { initializeUseSelector } from './hooks/useSelector';\nimport { initializeConnect } from './components/connect';\ninitializeUseSelector(useSyncExternalStoreWithSelector);\ninitializeConnect(useSyncExternalStore); // Enable batched updates in our subscriptions for use\n// with standard React renderers (ReactDOM, React Native)\n\nsetBatch(batch);\nexport { batch };\nexport * from './exports';","export { unstable_batchedUpdates } from 'react-dom';","// Default to a dummy \"batch\" implementation that just runs the callback\nfunction defaultNoopBatch(callback) {\n  callback();\n}\n\nlet batch = defaultNoopBatch; // Allow injecting another batching function later\n\nexport const setBatch = newBatch => batch = newBatch; // Supply a getter just to skip dealing with ESM bindings\n\nexport const getBatch = () => batch;","import { useCallback, useDebugValue, useRef } from 'react';\nimport { createReduxContextHook, useReduxContext as useDefaultReduxContext } from './useReduxContext';\nimport { ReactReduxContext } from '../components/Context';\nimport { notInitialized } from '../utils/useSyncExternalStore';\nlet useSyncExternalStoreWithSelector = notInitialized;\nexport const initializeUseSelector = fn => {\n  useSyncExternalStoreWithSelector = fn;\n};\n\nconst refEquality = (a, b) => a === b;\n/**\r\n * Hook factory, which creates a `useSelector` hook bound to a given context.\r\n *\r\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\r\n * @returns {Function} A `useSelector` hook bound to the specified context.\r\n */\n\n\nexport function createSelectorHook(context = ReactReduxContext) {\n  const useReduxContext = context === ReactReduxContext ? useDefaultReduxContext : createReduxContextHook(context);\n  return function useSelector(selector, equalityFnOrOptions = {}) {\n    const {\n      equalityFn = refEquality,\n      stabilityCheck = undefined,\n      noopCheck = undefined\n    } = typeof equalityFnOrOptions === 'function' ? {\n      equalityFn: equalityFnOrOptions\n    } : equalityFnOrOptions;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!selector) {\n        throw new Error(`You must pass a selector to useSelector`);\n      }\n\n      if (typeof selector !== 'function') {\n        throw new Error(`You must pass a function as a selector to useSelector`);\n      }\n\n      if (typeof equalityFn !== 'function') {\n        throw new Error(`You must pass a function as an equality function to useSelector`);\n      }\n    }\n\n    const {\n      store,\n      subscription,\n      getServerState,\n      stabilityCheck: globalStabilityCheck,\n      noopCheck: globalNoopCheck\n    } = useReduxContext();\n    const firstRun = useRef(true);\n    const wrappedSelector = useCallback({\n      [selector.name](state) {\n        const selected = selector(state);\n\n        if (process.env.NODE_ENV !== 'production') {\n          const finalStabilityCheck = typeof stabilityCheck === 'undefined' ? globalStabilityCheck : stabilityCheck;\n\n          if (finalStabilityCheck === 'always' || finalStabilityCheck === 'once' && firstRun.current) {\n            const toCompare = selector(state);\n\n            if (!equalityFn(selected, toCompare)) {\n              let stack = undefined;\n\n              try {\n                throw new Error();\n              } catch (e) {\n                ;\n                ({\n                  stack\n                } = e);\n              }\n\n              console.warn('Selector ' + (selector.name || 'unknown') + ' returned a different result when called with the same parameters. This can lead to unnecessary rerenders.' + '\\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization', {\n                state,\n                selected,\n                selected2: toCompare,\n                stack\n              });\n            }\n          }\n\n          const finalNoopCheck = typeof noopCheck === 'undefined' ? globalNoopCheck : noopCheck;\n\n          if (finalNoopCheck === 'always' || finalNoopCheck === 'once' && firstRun.current) {\n            // @ts-ignore\n            if (selected === state) {\n              let stack = undefined;\n\n              try {\n                throw new Error();\n              } catch (e) {\n                ;\n                ({\n                  stack\n                } = e);\n              }\n\n              console.warn('Selector ' + (selector.name || 'unknown') + ' returned the root state when called. This can lead to unnecessary rerenders.' + '\\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.', {\n                stack\n              });\n            }\n          }\n\n          if (firstRun.current) firstRun.current = false;\n        }\n\n        return selected;\n      }\n\n    }[selector.name], [selector, globalStabilityCheck, stabilityCheck]);\n    const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store.getState, getServerState || store.getState, wrappedSelector, equalityFn);\n    useDebugValue(selectedState);\n    return selectedState;\n  };\n}\n/**\r\n * A hook to access the redux store's state. This hook takes a selector function\r\n * as an argument. The selector is called with the store state.\r\n *\r\n * This hook takes an optional equality comparison function as the second parameter\r\n * that allows you to customize the way the selected state is compared to determine\r\n * whether the component needs to be re-rendered.\r\n *\r\n * @param {Function} selector the selector function\r\n * @param {Function=} equalityFn the function that will be used to determine equality\r\n *\r\n * @returns {any} the selected state\r\n *\r\n * @example\r\n *\r\n * import React from 'react'\r\n * import { useSelector } from 'react-redux'\r\n *\r\n * export const CounterComponent = () => {\r\n *   const counter = useSelector(state => state.counter)\r\n *   return <div>{counter}</div>\r\n * }\r\n */\n\nexport const useSelector = /*#__PURE__*/createSelectorHook();","import * as React from 'react';\nconst ContextKey = Symbol.for(`react-redux-context`);\nconst gT = typeof globalThis !== \"undefined\" ? globalThis :\n/* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */\n{};\n\nfunction getContext() {\n  var _gT$ContextKey;\n\n  if (!React.createContext) return {};\n  const contextMap = (_gT$ContextKey = gT[ContextKey]) != null ? _gT$ContextKey : gT[ContextKey] = new Map();\n  let realContext = contextMap.get(React.createContext);\n\n  if (!realContext) {\n    realContext = React.createContext(null);\n\n    if (process.env.NODE_ENV !== 'production') {\n      realContext.displayName = 'ReactRedux';\n    }\n\n    contextMap.set(React.createContext, realContext);\n  }\n\n  return realContext;\n}\n\nexport const ReactReduxContext = /*#__PURE__*/getContext();\nexport default ReactReduxContext;","import { useContext } from 'react';\nimport { ReactReduxContext } from '../components/Context';\n\n/**\r\n * Hook factory, which creates a `useReduxContext` hook bound to a given context. This is a low-level\r\n * hook that you should usually not need to call directly.\r\n *\r\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\r\n * @returns {Function} A `useReduxContext` hook bound to the specified context.\r\n */\nexport function createReduxContextHook(context = ReactReduxContext) {\n  return function useReduxContext() {\n    const contextValue = useContext(context);\n\n    if (process.env.NODE_ENV !== 'production' && !contextValue) {\n      throw new Error('could not find react-redux context value; please ensure the component is wrapped in a <Provider>');\n    }\n\n    return contextValue;\n  };\n}\n/**\r\n * A hook to access the value of the `ReactReduxContext`. This is a low-level\r\n * hook that you should usually not need to call directly.\r\n *\r\n * @returns {any} the value of the `ReactReduxContext`\r\n *\r\n * @example\r\n *\r\n * import React from 'react'\r\n * import { useReduxContext } from 'react-redux'\r\n *\r\n * export const CounterComponent = () => {\r\n *   const { store } = useReduxContext()\r\n *   return <div>{store.getState()}</div>\r\n * }\r\n */\n\nexport const useReduxContext = /*#__PURE__*/createReduxContextHook();","export const notInitialized = () => {\n  throw new Error('uSES not initialized!');\n};","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"reactReduxForwardedRef\"];\n\n/* eslint-disable valid-jsdoc, @typescript-eslint/no-unused-vars */\nimport hoistStatics from 'hoist-non-react-statics';\nimport * as React from 'react';\nimport { isValidElementType, isContextConsumer } from 'react-is';\nimport defaultSelectorFactory from '../connect/selectorFactory';\nimport { mapDispatchToPropsFactory } from '../connect/mapDispatchToProps';\nimport { mapStateToPropsFactory } from '../connect/mapStateToProps';\nimport { mergePropsFactory } from '../connect/mergeProps';\nimport { createSubscription } from '../utils/Subscription';\nimport { useIsomorphicLayoutEffect } from '../utils/useIsomorphicLayoutEffect';\nimport shallowEqual from '../utils/shallowEqual';\nimport warning from '../utils/warning';\nimport { ReactReduxContext } from './Context';\nimport { notInitialized } from '../utils/useSyncExternalStore';\nlet useSyncExternalStore = notInitialized;\nexport const initializeConnect = fn => {\n  useSyncExternalStore = fn;\n}; // Define some constant arrays just to avoid re-creating these\n\nconst EMPTY_ARRAY = [null, 0];\nconst NO_SUBSCRIPTION_ARRAY = [null, null]; // Attempts to stringify whatever not-really-a-component value we were given\n// for logging in an error message\n\nconst stringifyComponent = Comp => {\n  try {\n    return JSON.stringify(Comp);\n  } catch (err) {\n    return String(Comp);\n  }\n};\n\n// This is \"just\" a `useLayoutEffect`, but with two modifications:\n// - we need to fall back to `useEffect` in SSR to avoid annoying warnings\n// - we extract this to a separate function to avoid closing over values\n//   and causing memory leaks\nfunction useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {\n  useIsomorphicLayoutEffect(() => effectFunc(...effectArgs), dependencies);\n} // Effect callback, extracted: assign the latest props values to refs for later usage\n\n\nfunction captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, // actualChildProps: unknown,\nchildPropsFromStoreUpdate, notifyNestedSubs) {\n  // We want to capture the wrapper props and child props we used for later comparisons\n  lastWrapperProps.current = wrapperProps;\n  renderIsScheduled.current = false; // If the render was from a store update, clear out that reference and cascade the subscriber update\n\n  if (childPropsFromStoreUpdate.current) {\n    childPropsFromStoreUpdate.current = null;\n    notifyNestedSubs();\n  }\n} // Effect callback, extracted: subscribe to the Redux store or nearest connected ancestor,\n// check for updates after dispatched actions, and trigger re-renders.\n\n\nfunction subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, // forceComponentUpdateDispatch: React.Dispatch<any>,\nadditionalSubscribeListener) {\n  // If we're not subscribed to the store, nothing to do here\n  if (!shouldHandleStateChanges) return () => {}; // Capture values for checking if and when this component unmounts\n\n  let didUnsubscribe = false;\n  let lastThrownError = null; // We'll run this callback every time a store subscription update propagates to this component\n\n  const checkForUpdates = () => {\n    if (didUnsubscribe || !isMounted.current) {\n      // Don't run stale listeners.\n      // Redux doesn't guarantee unsubscriptions happen until next dispatch.\n      return;\n    } // TODO We're currently calling getState ourselves here, rather than letting `uSES` do it\n\n\n    const latestStoreState = store.getState();\n    let newChildProps, error;\n\n    try {\n      // Actually run the selector with the most recent store state and wrapper props\n      // to determine what the child props should be\n      newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);\n    } catch (e) {\n      error = e;\n      lastThrownError = e;\n    }\n\n    if (!error) {\n      lastThrownError = null;\n    } // If the child props haven't changed, nothing to do here - cascade the subscription update\n\n\n    if (newChildProps === lastChildProps.current) {\n      if (!renderIsScheduled.current) {\n        notifyNestedSubs();\n      }\n    } else {\n      // Save references to the new child props.  Note that we track the \"child props from store update\"\n      // as a ref instead of a useState/useReducer because we need a way to determine if that value has\n      // been processed.  If this went into useState/useReducer, we couldn't clear out the value without\n      // forcing another re-render, which we don't want.\n      lastChildProps.current = newChildProps;\n      childPropsFromStoreUpdate.current = newChildProps;\n      renderIsScheduled.current = true; // TODO This is hacky and not how `uSES` is meant to be used\n      // Trigger the React `useSyncExternalStore` subscriber\n\n      additionalSubscribeListener();\n    }\n  }; // Actually subscribe to the nearest connected ancestor (or store)\n\n\n  subscription.onStateChange = checkForUpdates;\n  subscription.trySubscribe(); // Pull data from the store after first render in case the store has\n  // changed since we began.\n\n  checkForUpdates();\n\n  const unsubscribeWrapper = () => {\n    didUnsubscribe = true;\n    subscription.tryUnsubscribe();\n    subscription.onStateChange = null;\n\n    if (lastThrownError) {\n      // It's possible that we caught an error due to a bad mapState function, but the\n      // parent re-rendered without this component and we're about to unmount.\n      // This shouldn't happen as long as we do top-down subscriptions correctly, but\n      // if we ever do those wrong, this throw will surface the error in our tests.\n      // In that case, throw the error from here so it doesn't get lost.\n      throw lastThrownError;\n    }\n  };\n\n  return unsubscribeWrapper;\n} // Reducer initial state creation for our update reducer\n\n\nconst initStateUpdates = () => EMPTY_ARRAY;\n\nfunction strictEqual(a, b) {\n  return a === b;\n}\n/**\r\n * Infers the type of props that a connector will inject into a component.\r\n */\n\n\nlet hasWarnedAboutDeprecatedPureOption = false;\n/**\r\n * Connects a React component to a Redux store.\r\n *\r\n * - Without arguments, just wraps the component, without changing the behavior / props\r\n *\r\n * - If 2 params are passed (3rd param, mergeProps, is skipped), default behavior\r\n * is to override ownProps (as stated in the docs), so what remains is everything that's\r\n * not a state or dispatch prop\r\n *\r\n * - When 3rd param is passed, we don't know if ownProps propagate and whether they\r\n * should be valid component props, because it depends on mergeProps implementation.\r\n * As such, it is the user's responsibility to extend ownProps interface from state or\r\n * dispatch props or both when applicable\r\n *\r\n * @param mapStateToProps A function that extracts values from state\r\n * @param mapDispatchToProps Setup for dispatching actions\r\n * @param mergeProps Optional callback to merge state and dispatch props together\r\n * @param options Options for configuring the connection\r\n *\r\n */\n\nfunction connect(mapStateToProps, mapDispatchToProps, mergeProps, {\n  // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.\n  // @ts-ignore\n  pure,\n  areStatesEqual = strictEqual,\n  areOwnPropsEqual = shallowEqual,\n  areStatePropsEqual = shallowEqual,\n  areMergedPropsEqual = shallowEqual,\n  // use React's forwardRef to expose a ref of the wrapped component\n  forwardRef = false,\n  // the context consumer to use\n  context = ReactReduxContext\n} = {}) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (pure !== undefined && !hasWarnedAboutDeprecatedPureOption) {\n      hasWarnedAboutDeprecatedPureOption = true;\n      warning('The `pure` option has been removed. `connect` is now always a \"pure/memoized\" component');\n    }\n  }\n\n  const Context = context;\n  const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);\n  const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);\n  const initMergeProps = mergePropsFactory(mergeProps);\n  const shouldHandleStateChanges = Boolean(mapStateToProps);\n\n  const wrapWithConnect = WrappedComponent => {\n    if (process.env.NODE_ENV !== 'production' && !isValidElementType(WrappedComponent)) {\n      throw new Error(`You must pass a component to the function returned by connect. Instead received ${stringifyComponent(WrappedComponent)}`);\n    }\n\n    const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';\n    const displayName = `Connect(${wrappedComponentName})`;\n    const selectorFactoryOptions = {\n      shouldHandleStateChanges,\n      displayName,\n      wrappedComponentName,\n      WrappedComponent,\n      // @ts-ignore\n      initMapStateToProps,\n      // @ts-ignore\n      initMapDispatchToProps,\n      initMergeProps,\n      areStatesEqual,\n      areStatePropsEqual,\n      areOwnPropsEqual,\n      areMergedPropsEqual\n    };\n\n    function ConnectFunction(props) {\n      const [propsContext, reactReduxForwardedRef, wrapperProps] = React.useMemo(() => {\n        // Distinguish between actual \"data\" props that were passed to the wrapper component,\n        // and values needed to control behavior (forwarded refs, alternate context instances).\n        // To maintain the wrapperProps object reference, memoize this destructuring.\n        const {\n          reactReduxForwardedRef\n        } = props,\n              wrapperProps = _objectWithoutPropertiesLoose(props, _excluded);\n\n        return [props.context, reactReduxForwardedRef, wrapperProps];\n      }, [props]);\n      const ContextToUse = React.useMemo(() => {\n        // Users may optionally pass in a custom context instance to use instead of our ReactReduxContext.\n        // Memoize the check that determines which context instance we should use.\n        return propsContext && propsContext.Consumer && // @ts-ignore\n        isContextConsumer( /*#__PURE__*/React.createElement(propsContext.Consumer, null)) ? propsContext : Context;\n      }, [propsContext, Context]); // Retrieve the store and ancestor subscription via context, if available\n\n      const contextValue = React.useContext(ContextToUse); // The store _must_ exist as either a prop or in context.\n      // We'll check to see if it _looks_ like a Redux store first.\n      // This allows us to pass through a `store` prop that is just a plain value.\n\n      const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);\n      const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);\n\n      if (process.env.NODE_ENV !== 'production' && !didStoreComeFromProps && !didStoreComeFromContext) {\n        throw new Error(`Could not find \"store\" in the context of ` + `\"${displayName}\". Either wrap the root component in a <Provider>, ` + `or pass a custom React context provider to <Provider> and the corresponding ` + `React context consumer to ${displayName} in connect options.`);\n      } // Based on the previous check, one of these must be true\n\n\n      const store = didStoreComeFromProps ? props.store : contextValue.store;\n      const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;\n      const childPropsSelector = React.useMemo(() => {\n        // The child props selector needs the store reference as an input.\n        // Re-create this selector whenever the store changes.\n        return defaultSelectorFactory(store.dispatch, selectorFactoryOptions);\n      }, [store]);\n      const [subscription, notifyNestedSubs] = React.useMemo(() => {\n        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY; // This Subscription's source should match where store came from: props vs. context. A component\n        // connected to the store via props shouldn't use subscription from context, or vice versa.\n\n        const subscription = createSubscription(store, didStoreComeFromProps ? undefined : contextValue.subscription); // `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in\n        // the middle of the notification loop, where `subscription` will then be null. This can\n        // probably be avoided if Subscription's listeners logic is changed to not call listeners\n        // that have been unsubscribed in the  middle of the notification loop.\n\n        const notifyNestedSubs = subscription.notifyNestedSubs.bind(subscription);\n        return [subscription, notifyNestedSubs];\n      }, [store, didStoreComeFromProps, contextValue]); // Determine what {store, subscription} value should be put into nested context, if necessary,\n      // and memoize that value to avoid unnecessary context updates.\n\n      const overriddenContextValue = React.useMemo(() => {\n        if (didStoreComeFromProps) {\n          // This component is directly subscribed to a store from props.\n          // We don't want descendants reading from this store - pass down whatever\n          // the existing context value is from the nearest connected ancestor.\n          return contextValue;\n        } // Otherwise, put this component's subscription instance into context, so that\n        // connected descendants won't update until after this component is done\n\n\n        return _extends({}, contextValue, {\n          subscription\n        });\n      }, [didStoreComeFromProps, contextValue, subscription]); // Set up refs to coordinate values between the subscription effect and the render logic\n\n      const lastChildProps = React.useRef();\n      const lastWrapperProps = React.useRef(wrapperProps);\n      const childPropsFromStoreUpdate = React.useRef();\n      const renderIsScheduled = React.useRef(false);\n      const isProcessingDispatch = React.useRef(false);\n      const isMounted = React.useRef(false);\n      const latestSubscriptionCallbackError = React.useRef();\n      useIsomorphicLayoutEffect(() => {\n        isMounted.current = true;\n        return () => {\n          isMounted.current = false;\n        };\n      }, []);\n      const actualChildPropsSelector = React.useMemo(() => {\n        const selector = () => {\n          // Tricky logic here:\n          // - This render may have been triggered by a Redux store update that produced new child props\n          // - However, we may have gotten new wrapper props after that\n          // If we have new child props, and the same wrapper props, we know we should use the new child props as-is.\n          // But, if we have new wrapper props, those might change the child props, so we have to recalculate things.\n          // So, we'll use the child props from store update only if the wrapper props are the same as last time.\n          if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {\n            return childPropsFromStoreUpdate.current;\n          } // TODO We're reading the store directly in render() here. Bad idea?\n          // This will likely cause Bad Things (TM) to happen in Concurrent Mode.\n          // Note that we do this because on renders _not_ caused by store updates, we need the latest store state\n          // to determine what the child props should be.\n\n\n          return childPropsSelector(store.getState(), wrapperProps);\n        };\n\n        return selector;\n      }, [store, wrapperProps]); // We need this to execute synchronously every time we re-render. However, React warns\n      // about useLayoutEffect in SSR, so we try to detect environment and fall back to\n      // just useEffect instead to avoid the warning, since neither will run anyway.\n\n      const subscribeForReact = React.useMemo(() => {\n        const subscribe = reactListener => {\n          if (!subscription) {\n            return () => {};\n          }\n\n          return subscribeUpdates(shouldHandleStateChanges, store, subscription, // @ts-ignore\n          childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, reactListener);\n        };\n\n        return subscribe;\n      }, [subscription]);\n      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs]);\n      let actualChildProps;\n\n      try {\n        actualChildProps = useSyncExternalStore( // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing\n        subscribeForReact, // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,\n        // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.\n        actualChildPropsSelector, getServerState ? () => childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector);\n      } catch (err) {\n        if (latestSubscriptionCallbackError.current) {\n          ;\n          err.message += `\\nThe error may be correlated with this previous error:\\n${latestSubscriptionCallbackError.current.stack}\\n\\n`;\n        }\n\n        throw err;\n      }\n\n      useIsomorphicLayoutEffect(() => {\n        latestSubscriptionCallbackError.current = undefined;\n        childPropsFromStoreUpdate.current = undefined;\n        lastChildProps.current = actualChildProps;\n      }); // Now that all that's done, we can finally try to actually render the child component.\n      // We memoize the elements for the rendered child component as an optimization.\n\n      const renderedWrappedComponent = React.useMemo(() => {\n        return (\n          /*#__PURE__*/\n          // @ts-ignore\n          React.createElement(WrappedComponent, _extends({}, actualChildProps, {\n            ref: reactReduxForwardedRef\n          }))\n        );\n      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]); // If React sees the exact same element reference as last time, it bails out of re-rendering\n      // that child, same as if it was wrapped in React.memo() or returned false from shouldComponentUpdate.\n\n      const renderedChild = React.useMemo(() => {\n        if (shouldHandleStateChanges) {\n          // If this component is subscribed to store updates, we need to pass its own\n          // subscription instance down to our descendants. That means rendering the same\n          // Context instance, and putting a different value into the context.\n          return /*#__PURE__*/React.createElement(ContextToUse.Provider, {\n            value: overriddenContextValue\n          }, renderedWrappedComponent);\n        }\n\n        return renderedWrappedComponent;\n      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);\n      return renderedChild;\n    }\n\n    const _Connect = React.memo(ConnectFunction);\n\n    // Add a hacky cast to get the right output type\n    const Connect = _Connect;\n    Connect.WrappedComponent = WrappedComponent;\n    Connect.displayName = ConnectFunction.displayName = displayName;\n\n    if (forwardRef) {\n      const _forwarded = React.forwardRef(function forwardConnectRef(props, ref) {\n        // @ts-ignore\n        return /*#__PURE__*/React.createElement(Connect, _extends({}, props, {\n          reactReduxForwardedRef: ref\n        }));\n      });\n\n      const forwarded = _forwarded;\n      forwarded.displayName = displayName;\n      forwarded.WrappedComponent = WrappedComponent;\n      return hoistStatics(forwarded, WrappedComponent);\n    }\n\n    return hoistStatics(Connect, WrappedComponent);\n  };\n\n  return wrapWithConnect;\n}\n\nexport default connect;","/**\r\n * Prints a warning in the console if it exists.\r\n *\r\n * @param {String} message The warning message.\r\n * @returns {void}\r\n */\nexport default function warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n\n\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // \"break on all exceptions\" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n    /* eslint-disable no-empty */\n  } catch (e) {}\n  /* eslint-enable no-empty */\n\n}","import warning from '../utils/warning';\n\nfunction verify(selector, methodName) {\n  if (!selector) {\n    throw new Error(`Unexpected value for ${methodName} in connect.`);\n  } else if (methodName === 'mapStateToProps' || methodName === 'mapDispatchToProps') {\n    if (!Object.prototype.hasOwnProperty.call(selector, 'dependsOnOwnProps')) {\n      warning(`The selector for ${methodName} of connect did not specify a value for dependsOnOwnProps.`);\n    }\n  }\n}\n\nexport default function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {\n  verify(mapStateToProps, 'mapStateToProps');\n  verify(mapDispatchToProps, 'mapDispatchToProps');\n  verify(mergeProps, 'mergeProps');\n}","import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"initMapStateToProps\", \"initMapDispatchToProps\", \"initMergeProps\"];\nimport verifySubselectors from './verifySubselectors';\nexport function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, {\n  areStatesEqual,\n  areOwnPropsEqual,\n  areStatePropsEqual\n}) {\n  let hasRunAtLeastOnce = false;\n  let state;\n  let ownProps;\n  let stateProps;\n  let dispatchProps;\n  let mergedProps;\n\n  function handleFirstCall(firstState, firstOwnProps) {\n    state = firstState;\n    ownProps = firstOwnProps;\n    stateProps = mapStateToProps(state, ownProps);\n    dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    hasRunAtLeastOnce = true;\n    return mergedProps;\n  }\n\n  function handleNewPropsAndNewState() {\n    stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n\n  function handleNewProps() {\n    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);\n    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n\n  function handleNewState() {\n    const nextStateProps = mapStateToProps(state, ownProps);\n    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\n    stateProps = nextStateProps;\n    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n    return mergedProps;\n  }\n\n  function handleSubsequentCalls(nextState, nextOwnProps) {\n    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\n    const stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);\n    state = nextState;\n    ownProps = nextOwnProps;\n    if (propsChanged && stateChanged) return handleNewPropsAndNewState();\n    if (propsChanged) return handleNewProps();\n    if (stateChanged) return handleNewState();\n    return mergedProps;\n  }\n\n  return function pureFinalPropsSelector(nextState, nextOwnProps) {\n    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\n  };\n}\n// TODO: Add more comments\n// The selector returned by selectorFactory will memoize its results,\n// allowing connect's shouldComponentUpdate to return false if final\n// props have not changed.\nexport default function finalPropsSelectorFactory(dispatch, _ref) {\n  let {\n    initMapStateToProps,\n    initMapDispatchToProps,\n    initMergeProps\n  } = _ref,\n      options = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  const mapStateToProps = initMapStateToProps(dispatch, options);\n  const mapDispatchToProps = initMapDispatchToProps(dispatch, options);\n  const mergeProps = initMergeProps(dispatch, options);\n\n  if (process.env.NODE_ENV !== 'production') {\n    verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps);\n  }\n\n  return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\n}","export default function bindActionCreators(actionCreators, dispatch) {\n  const boundActionCreators = {};\n\n  for (const key in actionCreators) {\n    const actionCreator = actionCreators[key];\n\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = (...args) => dispatch(actionCreator(...args));\n    }\n  }\n\n  return boundActionCreators;\n}","/**\r\n * @param {any} obj The object to inspect.\r\n * @returns {boolean} True if the argument appears to be a plain object.\r\n */\nexport default function isPlainObject(obj) {\n  if (typeof obj !== 'object' || obj === null) return false;\n  let proto = Object.getPrototypeOf(obj);\n  if (proto === null) return true;\n  let baseProto = proto;\n\n  while (Object.getPrototypeOf(baseProto) !== null) {\n    baseProto = Object.getPrototypeOf(baseProto);\n  }\n\n  return proto === baseProto;\n}","import isPlainObject from './isPlainObject';\nimport warning from './warning';\nexport default function verifyPlainObject(value, displayName, methodName) {\n  if (!isPlainObject(value)) {\n    warning(`${methodName}() in ${displayName} must return a plain object. Instead received ${value}.`);\n  }\n}","import verifyPlainObject from '../utils/verifyPlainObject';\nexport function wrapMapToPropsConstant( // * Note:\n//  It seems that the dispatch argument\n//  could be a dispatch function in some cases (ex: whenMapDispatchToPropsIsMissing)\n//  and a state object in some others (ex: whenMapStateToPropsIsMissing)\n// eslint-disable-next-line no-unused-vars\ngetConstant) {\n  return function initConstantSelector(dispatch) {\n    const constant = getConstant(dispatch);\n\n    function constantSelector() {\n      return constant;\n    }\n\n    constantSelector.dependsOnOwnProps = false;\n    return constantSelector;\n  };\n} // dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args\n// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine\n// whether mapToProps needs to be invoked when props have changed.\n//\n// A length of one signals that mapToProps does not depend on props from the parent component.\n// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and\n// therefore not reporting its length accurately..\n// TODO Can this get pulled out so that we can subscribe directly to the store if we don't need ownProps?\n\nexport function getDependsOnOwnProps(mapToProps) {\n  return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;\n} // Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,\n// this function wraps mapToProps in a proxy function which does several things:\n//\n//  * Detects whether the mapToProps function being called depends on props, which\n//    is used by selectorFactory to decide if it should reinvoke on props changes.\n//\n//  * On first call, handles mapToProps if returns another function, and treats that\n//    new function as the true mapToProps for subsequent calls.\n//\n//  * On first call, verifies the first result is a plain object, in order to warn\n//    the developer that their mapToProps function is not returning a valid result.\n//\n\nexport function wrapMapToPropsFunc(mapToProps, methodName) {\n  return function initProxySelector(dispatch, {\n    displayName\n  }) {\n    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\n      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, undefined);\n    }; // allow detectFactoryAndVerify to get ownProps\n\n\n    proxy.dependsOnOwnProps = true;\n\n    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {\n      proxy.mapToProps = mapToProps;\n      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\n      let props = proxy(stateOrDispatch, ownProps);\n\n      if (typeof props === 'function') {\n        proxy.mapToProps = props;\n        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\n        props = proxy(stateOrDispatch, ownProps);\n      }\n\n      if (process.env.NODE_ENV !== 'production') verifyPlainObject(props, displayName, methodName);\n      return props;\n    };\n\n    return proxy;\n  };\n}","export function createInvalidArgFactory(arg, name) {\n  return (dispatch, options) => {\n    throw new Error(`Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`);\n  };\n}","import bindActionCreators from '../utils/bindActionCreators';\nimport { wrapMapToPropsConstant, wrapMapToPropsFunc } from './wrapMapToProps';\nimport { createInvalidArgFactory } from './invalidArgFactory';\nexport function mapDispatchToPropsFactory(mapDispatchToProps) {\n  return mapDispatchToProps && typeof mapDispatchToProps === 'object' ? wrapMapToPropsConstant(dispatch => // @ts-ignore\n  bindActionCreators(mapDispatchToProps, dispatch)) : !mapDispatchToProps ? wrapMapToPropsConstant(dispatch => ({\n    dispatch\n  })) : typeof mapDispatchToProps === 'function' ? // @ts-ignore\n  wrapMapToPropsFunc(mapDispatchToProps, 'mapDispatchToProps') : createInvalidArgFactory(mapDispatchToProps, 'mapDispatchToProps');\n}","import { wrapMapToPropsConstant, wrapMapToPropsFunc } from './wrapMapToProps';\nimport { createInvalidArgFactory } from './invalidArgFactory';\nexport function mapStateToPropsFactory(mapStateToProps) {\n  return !mapStateToProps ? wrapMapToPropsConstant(() => ({})) : typeof mapStateToProps === 'function' ? // @ts-ignore\n  wrapMapToPropsFunc(mapStateToProps, 'mapStateToProps') : createInvalidArgFactory(mapStateToProps, 'mapStateToProps');\n}","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport verifyPlainObject from '../utils/verifyPlainObject';\nimport { createInvalidArgFactory } from './invalidArgFactory';\nexport function defaultMergeProps(stateProps, dispatchProps, ownProps) {\n  // @ts-ignore\n  return _extends({}, ownProps, stateProps, dispatchProps);\n}\nexport function wrapMergePropsFunc(mergeProps) {\n  return function initMergePropsProxy(dispatch, {\n    displayName,\n    areMergedPropsEqual\n  }) {\n    let hasRunOnce = false;\n    let mergedProps;\n    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {\n      const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n\n      if (hasRunOnce) {\n        if (!areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;\n      } else {\n        hasRunOnce = true;\n        mergedProps = nextMergedProps;\n        if (process.env.NODE_ENV !== 'production') verifyPlainObject(mergedProps, displayName, 'mergeProps');\n      }\n\n      return mergedProps;\n    };\n  };\n}\nexport function mergePropsFactory(mergeProps) {\n  return !mergeProps ? () => defaultMergeProps : typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, 'mergeProps');\n}","import { getBatch } from './batch'; // encapsulates the subscription logic for connecting a component to the redux store, as\n// well as nesting subscriptions of descendant components, so that we can ensure the\n// ancestor components re-render before descendants\n\nfunction createListenerCollection() {\n  const batch = getBatch();\n  let first = null;\n  let last = null;\n  return {\n    clear() {\n      first = null;\n      last = null;\n    },\n\n    notify() {\n      batch(() => {\n        let listener = first;\n\n        while (listener) {\n          listener.callback();\n          listener = listener.next;\n        }\n      });\n    },\n\n    get() {\n      let listeners = [];\n      let listener = first;\n\n      while (listener) {\n        listeners.push(listener);\n        listener = listener.next;\n      }\n\n      return listeners;\n    },\n\n    subscribe(callback) {\n      let isSubscribed = true;\n      let listener = last = {\n        callback,\n        next: null,\n        prev: last\n      };\n\n      if (listener.prev) {\n        listener.prev.next = listener;\n      } else {\n        first = listener;\n      }\n\n      return function unsubscribe() {\n        if (!isSubscribed || first === null) return;\n        isSubscribed = false;\n\n        if (listener.next) {\n          listener.next.prev = listener.prev;\n        } else {\n          last = listener.prev;\n        }\n\n        if (listener.prev) {\n          listener.prev.next = listener.next;\n        } else {\n          first = listener.next;\n        }\n      };\n    }\n\n  };\n}\n\nconst nullListeners = {\n  notify() {},\n\n  get: () => []\n};\nexport function createSubscription(store, parentSub) {\n  let unsubscribe;\n  let listeners = nullListeners; // Reasons to keep the subscription active\n\n  let subscriptionsAmount = 0; // Is this specific subscription subscribed (or only nested ones?)\n\n  let selfSubscribed = false;\n\n  function addNestedSub(listener) {\n    trySubscribe();\n    const cleanupListener = listeners.subscribe(listener); // cleanup nested sub\n\n    let removed = false;\n    return () => {\n      if (!removed) {\n        removed = true;\n        cleanupListener();\n        tryUnsubscribe();\n      }\n    };\n  }\n\n  function notifyNestedSubs() {\n    listeners.notify();\n  }\n\n  function handleChangeWrapper() {\n    if (subscription.onStateChange) {\n      subscription.onStateChange();\n    }\n  }\n\n  function isSubscribed() {\n    return selfSubscribed;\n  }\n\n  function trySubscribe() {\n    subscriptionsAmount++;\n\n    if (!unsubscribe) {\n      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);\n      listeners = createListenerCollection();\n    }\n  }\n\n  function tryUnsubscribe() {\n    subscriptionsAmount--;\n\n    if (unsubscribe && subscriptionsAmount === 0) {\n      unsubscribe();\n      unsubscribe = undefined;\n      listeners.clear();\n      listeners = nullListeners;\n    }\n  }\n\n  function trySubscribeSelf() {\n    if (!selfSubscribed) {\n      selfSubscribed = true;\n      trySubscribe();\n    }\n  }\n\n  function tryUnsubscribeSelf() {\n    if (selfSubscribed) {\n      selfSubscribed = false;\n      tryUnsubscribe();\n    }\n  }\n\n  const subscription = {\n    addNestedSub,\n    notifyNestedSubs,\n    handleChangeWrapper,\n    isSubscribed,\n    trySubscribe: trySubscribeSelf,\n    tryUnsubscribe: tryUnsubscribeSelf,\n    getListeners: () => listeners\n  };\n  return subscription;\n}","import * as React from 'react'; // React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store\n// subscription callback always has the selector from the latest render commit\n// available, otherwise a store update may happen between render and the effect,\n// which may cause missed updates; we also must ensure the store subscription\n// is created synchronously, otherwise a store update may occur before the\n// subscription is created and an inconsistent state may be observed\n// Matches logic in React's `shared/ExecutionEnvironment` file\n\nexport const canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\nexport const useIsomorphicLayoutEffect = canUseDOM ? React.useLayoutEffect : React.useEffect;","function is(x, y) {\n  if (x === y) {\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\nexport default function shallowEqual(objA, objB) {\n  if (is(objA, objB)) return true;\n\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n  if (keysA.length !== keysB.length) return false;\n\n  for (let i = 0; i < keysA.length; i++) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}","import * as React from 'react';\nimport { ReactReduxContext } from './Context';\nimport { createSubscription } from '../utils/Subscription';\nimport { useIsomorphicLayoutEffect } from '../utils/useIsomorphicLayoutEffect';\n\nfunction Provider({\n  store,\n  context,\n  children,\n  serverState,\n  stabilityCheck = 'once',\n  noopCheck = 'once'\n}) {\n  const contextValue = React.useMemo(() => {\n    const subscription = createSubscription(store);\n    return {\n      store,\n      subscription,\n      getServerState: serverState ? () => serverState : undefined,\n      stabilityCheck,\n      noopCheck\n    };\n  }, [store, serverState, stabilityCheck, noopCheck]);\n  const previousState = React.useMemo(() => store.getState(), [store]);\n  useIsomorphicLayoutEffect(() => {\n    const {\n      subscription\n    } = contextValue;\n    subscription.onStateChange = subscription.notifyNestedSubs;\n    subscription.trySubscribe();\n\n    if (previousState !== store.getState()) {\n      subscription.notifyNestedSubs();\n    }\n\n    return () => {\n      subscription.tryUnsubscribe();\n      subscription.onStateChange = undefined;\n    };\n  }, [contextValue, previousState]);\n  const Context = context || ReactReduxContext; // @ts-ignore 'AnyAction' is assignable to the constraint of type 'A', but 'A' could be instantiated with a different subtype\n\n  return /*#__PURE__*/React.createElement(Context.Provider, {\n    value: contextValue\n  }, children);\n}\n\nexport default Provider;","import { ReactReduxContext } from '../components/Context';\nimport { useReduxContext as useDefaultReduxContext, createReduxContextHook } from './useReduxContext';\n/**\r\n * Hook factory, which creates a `useStore` hook bound to a given context.\r\n *\r\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\r\n * @returns {Function} A `useStore` hook bound to the specified context.\r\n */\n\nexport function createStoreHook(context = ReactReduxContext) {\n  const useReduxContext = // @ts-ignore\n  context === ReactReduxContext ? useDefaultReduxContext : // @ts-ignore\n  createReduxContextHook(context);\n  return function useStore() {\n    const {\n      store\n    } = useReduxContext(); // @ts-ignore\n\n    return store;\n  };\n}\n/**\r\n * A hook to access the redux store.\r\n *\r\n * @returns {any} the redux store\r\n *\r\n * @example\r\n *\r\n * import React from 'react'\r\n * import { useStore } from 'react-redux'\r\n *\r\n * export const ExampleComponent = () => {\r\n *   const store = useStore()\r\n *   return <div>{store.getState()}</div>\r\n * }\r\n */\n\nexport const useStore = /*#__PURE__*/createStoreHook();","import { ReactReduxContext } from '../components/Context';\nimport { useStore as useDefaultStore, createStoreHook } from './useStore';\n/**\r\n * Hook factory, which creates a `useDispatch` hook bound to a given context.\r\n *\r\n * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.\r\n * @returns {Function} A `useDispatch` hook bound to the specified context.\r\n */\n\nexport function createDispatchHook(context = ReactReduxContext) {\n  const useStore = // @ts-ignore\n  context === ReactReduxContext ? useDefaultStore : createStoreHook(context);\n  return function useDispatch() {\n    const store = useStore(); // @ts-ignore\n\n    return store.dispatch;\n  };\n}\n/**\r\n * A hook to access the redux `dispatch` function.\r\n *\r\n * @returns {any|function} redux store's `dispatch` function\r\n *\r\n * @example\r\n *\r\n * import React, { useCallback } from 'react'\r\n * import { useDispatch } from 'react-redux'\r\n *\r\n * export const CounterComponent = ({ value }) => {\r\n *   const dispatch = useDispatch()\r\n *   const increaseCounter = useCallback(() => dispatch({ type: 'increase-counter' }), [])\r\n *   return (\r\n *     <div>\r\n *       <span>{value}</span>\r\n *       <button onClick={increaseCounter}>Increase counter</button>\r\n *     </div>\r\n *   )\r\n * }\r\n */\n\nexport const useDispatch = /*#__PURE__*/createDispatchHook();"],"names":[],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]}